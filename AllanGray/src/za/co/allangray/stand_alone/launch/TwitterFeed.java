package za.co.allangray.stand_alone.launch;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import za.co.allangray.stand_alone.exception.TweetException;
import za.co.allangray.stand_alone.utils.ResourceUtils;

public class TwitterFeed {

	private static ResourceUtils resourceUtils = null;
	private static Set<String> userFeeds = null;
	private static TreeMap<String, List<String>> userFollowersMap = null;
	private static List<String> twitterUsers = null;

	static {

		try {
			userFollowersMap = new TreeMap<>();
			resourceUtils = new ResourceUtils();
			userFeeds = new HashSet<String>(readSmallTextFile(resourceUtils.getTweetFile()));
			twitterUsers = readSmallTextFile(resourceUtils.getUsers());
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Program execution starts here.
	 * 
	 * @param aArgs
	 *            from the users/ generated by JVM.
	 */
	public static void main(String... aArgs) throws TweetException {

		try {
			TwitterFeed.startProcess();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Note: the javadoc of Files.readAllLines says it's intended for small
	 * files. But its implementation uses buffering, so it's likely good even
	 * for fairly large files.
	 */
	private static List<String> readSmallTextFile(String fileName) throws IOException {
		Path path = Paths.get(fileName);
		return Files.readAllLines(path, resourceUtils.getEncoding());
	}

	/**
	 * Start processing the files and populate data objects accordingly. This
	 * method calls the <code>readSmallTextFile</code> to read the files and
	 * return a list of file contents
	 */
	private static void startProcess() {

		try {

			// Start to process the file and compile user' followers.
			processUserFollowers(twitterUsers);

			// Start to display user' twitter feed alphabetically.
			processUserTwitterFeed();

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	/**
	 * This method extracts the list of twitter users and compiles a list of
	 * followers a user has.
	 * 
	 * @param twitterUsrs
	 */
	private static void processUserFollowers(List<String> twitterUsrs) {

		try {
			for (String users : twitterUsrs) {
				if (users.contains(resourceUtils.getFollows())) {
					userFollowersMap.put(getUsername(users), getFollowers(users));
				}
			}
			// determine whether a user is following other users.
			isUserFollowingOtherUsers(twitterUsrs);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Determines if the user being followed, follows anyone.
	 * 
	 * @param twitterUsrs
	 */
	private static void isUserFollowingOtherUsers(List<String> twitterUsrs) {

		StringBuilder sb = null;
		List<String> listOfUsers = null;
		try {
			sb = new StringBuilder();
			listOfUsers = new ArrayList<String>();
			sb.append(twitterUsrs.toString());
			
			for (String user : twitterUsrs) {
				user = user.replace(resourceUtils.getFollows(), resourceUtils.getEmptyString());
				user = user.substring(user.indexOf(resourceUtils.getSpace()), user.length()).trim();
				
				if (user.contains(resourceUtils.getComma())) {
					listOfUsers = Arrays.asList(user.trim().split(resourceUtils.getComma()));
					for (String uName : listOfUsers) {
						if (!(sb.toString().contains(uName + resourceUtils.getSpace() + resourceUtils.getFollows()))) {
							userFollowersMap.put(uName.trim(), new ArrayList<String>());
						}
					}
				} else {
					if (!(sb.toString().contains(user + resourceUtils.getSpace() + resourceUtils.getFollows()))) {
						userFollowersMap.put(user, new ArrayList<String>());
					}
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * This method loops through the usernames and then displays the twitter
	 * feeds alphabetically.
	 * 
	 * @param userFollowersMap2
	 * @param userFeeds2
	 */
	private static void processUserTwitterFeed() {

		try {

			for (Entry<String, List<String>> entry : userFollowersMap.entrySet()) {
				String username = entry.getKey();
				List<String> followers = entry.getValue();

				displayUserFeed(username, followers);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * This method determines who follows who and then displays the feeds of the
	 * user.
	 * 
	 * @param username
	 * @param followers
	 */
	private static void displayUserFeed(String username, List<String> followers) {

		TreeSet<String> tempFeeds = null;
		TreeSet<String> followersLst = null;
		try {
			System.out.println(username);

			tempFeeds = new TreeSet<String>();
			followersLst = new TreeSet<String>(followers);

			// Get user feeds.
			for (String feed : userFeeds) {
				if (feed.contains(username)) {
					tempFeeds.add(feed);
				}
			}

			// Get user followers feeds.
			for (String usrFollwr : followersLst) {
				for (String feed : userFeeds) {
					if (feed.contains(usrFollwr.trim())) {
						tempFeeds.add(feed);
					}
				}
			}

			// formats and displays the feed.
			formatAndDisplayFeed(tempFeeds);

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * This method formats and displays the feeds.
	 * 
	 * @param tempFeeds
	 */
	private static void formatAndDisplayFeed(TreeSet<String> tempFeeds) {

		StringBuilder sb = null;
		try {
			for (String feed : tempFeeds) {
				sb = new StringBuilder();
				sb.append(feed);
				sb.insert(resourceUtils.getZeroIndex(), resourceUtils.getTab() + resourceUtils.getAt());
				sb.replace(sb.indexOf(resourceUtils.getGt()), sb.indexOf(resourceUtils.getGt()) + 1, ":");
				log(sb.toString());
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	/**
	 * This method compiles a list of user followers.
	 * 
	 * @param users
	 * @return
	 */
	private static List<String> getFollowers(String users) {

		List<String> followers = null;
		try {
			followers = new ArrayList<String>();
			if (users.contains(resourceUtils.getFollows())) {
				users = users.replace(resourceUtils.getFollows(), resourceUtils.getEmptyString());
				users = users.substring(users.indexOf(resourceUtils.getSpace()), users.length()).trim();
				if (users.contains(resourceUtils.getComma())) {
					followers.addAll(Arrays.asList(users.split(resourceUtils.getComma())));
				} else {
					followers.add(users.trim());
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return followers;
	}

	/**
	 * This method extracts the user name of the user being followed.
	 * 
	 * @param users
	 * @return
	 */
	private static String getUsername(String users) {

		String username = null;
		try {
			username = (users.substring(resourceUtils.getZeroIndex(), users.indexOf(resourceUtils.getFollows())))
					.trim();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return username;
	}

	/**
	 * This method reads a text file, using Java.io Scanner. Used try with
	 * resource so as there is an AutoClosable to the Scanner.
	 * 
	 * @param fileName
	 * @throws IOException
	 */
	void readTextFileAlternate(String fileName) throws IOException {
		Path path = Paths.get(fileName);
		try (BufferedReader reader = Files.newBufferedReader(path, resourceUtils.getEncoding())) {
			String line = null;
			while ((line = reader.readLine()) != null) {
				log(line);
			}
		}
	}

	/**
	 * Log the FEED.
	 * 
	 * @param aMsg
	 */
	private static void log(Object aMsg) {
		System.out.println(String.valueOf(aMsg));
	}
}